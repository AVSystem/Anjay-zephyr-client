/*
 * Copyright 2020-2021 AVSystem <avsystem@avsystem.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generated by anjay_codegen.py on 2021-08-02 12:50:18
 *
 * LwM2M Object: Pattern detector
 * ID: 33650, URN: urn:oma:lwm2m:ext:33650, Optional, Multiple
 *
 * This object is used to report the pattern detected by the ML-based
 * classification algorithms and to count the number of times it has been
 * detected.
 */
#include <assert.h>
#include <stdbool.h>

#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_list.h>
#include <avsystem/commons/avs_memory.h>

#include <drivers/sensor.h>
#include <logging/log.h>
#include <zephyr.h>

#include "../inference.h"
#include "../led.h"
#include "objects.h"

LOG_MODULE_REGISTER(pattern_detector);

/**
 * Detector State: R, Single, Mandatory
 * type: boolean, range: N/A, unit: N/A
 * The current state of a detector.
 */
#define RID_DETECTOR_STATE 2000

/**
 * Detector Counter: R, Single, Mandatory
 * type: integer, range: N/A, unit: N/A
 * The cumulative value of patterns detected.
 */
#define RID_DETECTOR_COUNTER 2001

/**
 * Pattern Name: R, Single, Mandatory
 * type: string, range: N/A, unit: N/A
 * Name of the pattern being detected.
 */
#define RID_PATTERN_NAME 2002

#define ACCELEROMETER_NODE DT_INST(0, adi_adxl362)

#if !DT_NODE_HAS_STATUS(ACCELEROMETER_NODE, okay)
#    error "ADXL362 not available"
#endif // !DT_NODE_HAS_STATUS(ACCELEROMETER_NODE, okay)

#define SENSOR_CHANNEL SENSOR_CHAN_ACCEL_XYZ
#define CH_COUNT 3

typedef struct pattern_detector_instance_state_struct {
    bool detector_state;
    int32_t detector_counter;
} pattern_detector_instance_state_t;

typedef struct pattern_detector_instance_struct {
    anjay_iid_t iid;

    pattern_detector_instance_state_t curr_state;
    pattern_detector_instance_state_t cached_state;
    const char *pattern_name;
} pattern_detector_instance_t;

typedef struct pattern_detector_object_struct {
    const anjay_dm_object_def_t *def;
    const struct device *dev;

    pattern_detector_instance_t *instances;
    struct k_mutex instance_state_mtx;

    struct k_work_delayable measure_accel_dwork;
    struct k_work_sync sync;
    size_t next_sample_no;
    int64_t last_run_timestamp;
    float inference_data[];
} pattern_detector_object_t;

static const pattern_detector_instance_state_t INITIAL_STATE = {
    .detector_state = false,
    .detector_counter = 0
};

#define SYNCHRONIZED(Mtx)                                          \
    for (int _synchronized_exit = k_mutex_lock(&(Mtx), K_FOREVER); \
         !_synchronized_exit; _synchronized_exit = -1, k_mutex_unlock(&(Mtx)))

static void schedule_next_measure(pattern_detector_object_t *obj) {
    const int64_t next_run_timestamp =
            obj->last_run_timestamp + ML_SAMPLING_INTERVAL_MS;
    const int64_t curr_time = k_uptime_get();
    k_timeout_t next_run_delay;

    if (next_run_timestamp <= curr_time) {
        LOG_DBG("Pattern detector's timer has slipped");

        next_run_delay = K_NO_WAIT;
        obj->last_run_timestamp = curr_time;
    } else {
        next_run_delay = K_MSEC(next_run_timestamp - curr_time);
        obj->last_run_timestamp = next_run_timestamp;
    }

    k_work_schedule(&obj->measure_accel_dwork, next_run_delay);
}

static pattern_detector_instance_t *
find_instance(const pattern_detector_object_t *obj, anjay_iid_t iid) {
    return iid < ML_LABEL_COUNT ? &obj->instances[iid] : NULL;
}

static void measure_accel_handler(struct k_work *work) {
    assert(ML_SAMPLES_PER_FRAME == CH_COUNT);

    struct k_work_delayable *dwork = k_work_delayable_from_work(work);
    pattern_detector_object_t *obj =
            AVS_CONTAINER_OF(dwork, pattern_detector_object_t,
                             measure_accel_dwork);

    struct sensor_value values[CH_COUNT];
    if (sensor_sample_fetch_chan(obj->dev, SENSOR_CHANNEL)
            || sensor_channel_get(obj->dev, SENSOR_CHANNEL, values)) {
        LOG_ERR("Failed to fetch accelerometer data");
        return;
    }

    for (size_t i = 0; i < CH_COUNT; i++) {
        obj->inference_data[obj->next_sample_no * CH_COUNT + i] =
                (float) sensor_value_to_double(&values[i]);
    }

    if (++obj->next_sample_no == ML_SAMPLE_COUNT) {
        obj->next_sample_no = 0;

        int res = run_ml_inference(obj->inference_data);

        SYNCHRONIZED(obj->instance_state_mtx) {
            if (res < 0) {
                LOG_INF("No classification");

                for (size_t i = 0; i < ML_LABEL_COUNT; i++) {
                    pattern_detector_instance_t *it = &obj->instances[i];
                    it->curr_state.detector_state = false;
                    led_off(i);
                }
            } else {
                LOG_INF("Classified: %s", ML_LABELS[res]);

                for (size_t i = 0; i < ML_LABEL_COUNT; i++) {
                    pattern_detector_instance_t *it = &obj->instances[i];
                    if (it->iid == res) {
                        it->curr_state.detector_state = true;
                        it->curr_state.detector_counter++;
                        led_on(i);
                    } else {
                        it->curr_state.detector_state = false;
                        led_off(i);
                    }
                }
            }
        }
    }

    schedule_next_measure(obj);
}

static inline pattern_detector_object_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, pattern_detector_object_t, def);
}

static int list_instances(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_dm_list_ctx_t *ctx) {
    (void) anjay;

    for (size_t i = 0; i < ML_LABEL_COUNT; i++) {
        anjay_dm_emit(ctx, i);
    }

    return 0;
}

static int init_instance(pattern_detector_instance_t *inst, anjay_iid_t iid) {
    assert(iid != ANJAY_ID_INVALID);
    assert(iid < ML_LABEL_COUNT);

    inst->iid = iid;
    inst->curr_state = INITIAL_STATE;
    inst->cached_state = INITIAL_STATE;
    inst->pattern_name = ML_LABELS[iid];

    return 0;
}

static pattern_detector_instance_t *add_instance(pattern_detector_object_t *obj,
                                                 anjay_iid_t iid) {
    pattern_detector_instance_t *created = &obj->instances[iid];
    return init_instance(created, iid) ? NULL : created;
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

    anjay_dm_emit_res(ctx, RID_DETECTOR_STATE, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_DETECTOR_COUNTER, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_PATTERN_NAME, ANJAY_DM_RES_R,
                      ANJAY_DM_RES_PRESENT);
    return 0;
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;

    pattern_detector_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    pattern_detector_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    switch (rid) {
    case RID_DETECTOR_STATE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_bool(ctx, inst->cached_state.detector_state);

    case RID_DETECTOR_COUNTER:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, inst->cached_state.detector_counter);

    case RID_PATTERN_NAME:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, inst->pattern_name);

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = 33650,
    .handlers = {
        .list_instances = list_instances,

        .list_resources = list_resources,
        .resource_read = resource_read,
    }
};

const anjay_dm_object_def_t **pattern_detector_object_create(void) {
    static const struct device *dev = DEVICE_DT_GET(ACCELEROMETER_NODE);
    if (!device_is_ready(dev)) {
        return NULL;
    }

    pattern_detector_object_t *obj = (pattern_detector_object_t *) avs_calloc(
            1,
            sizeof(pattern_detector_object_t)
                    + ML_SAMPLE_COUNT * ML_SAMPLES_PER_FRAME * sizeof(float));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;
    obj->dev = dev;

    obj->instances = (pattern_detector_instance_t *) avs_calloc(
            ML_LABEL_COUNT, sizeof(pattern_detector_instance_t));
    if (!obj->instances) {
        pattern_detector_object_release(&obj->def);
        return NULL;
    }

    for (size_t i = 0; i < ML_LABEL_COUNT; i++) {
        if (!add_instance(obj, i)) {
            pattern_detector_object_release(&obj->def);
            return NULL;
        }
    }
    k_mutex_init(&obj->instance_state_mtx);

    k_work_init_delayable(&obj->measure_accel_dwork, measure_accel_handler);
    obj->next_sample_no = 0;
    obj->last_run_timestamp = k_uptime_get();
    schedule_next_measure(obj);

    return &obj->def;
}

void pattern_detector_object_update(anjay_t *anjay,
                                    const anjay_dm_object_def_t *const *def) {
    if (!anjay || !def) {
        return;
    }

    pattern_detector_object_t *obj = get_obj(def);

    SYNCHRONIZED(obj->instance_state_mtx) {
        for (size_t i = 0; i < ML_LABEL_COUNT; i++) {
            pattern_detector_instance_t *it = &obj->instances[i];

            if (it->cached_state.detector_state
                    != it->curr_state.detector_state) {
                it->cached_state.detector_state = it->curr_state.detector_state;
                anjay_notify_changed(anjay, obj->def->oid, i,
                                     RID_DETECTOR_STATE);
            }

            if (it->cached_state.detector_counter
                    != it->curr_state.detector_counter) {
                it->cached_state.detector_counter =
                        it->curr_state.detector_counter;
                anjay_notify_changed(anjay, obj->def->oid, i,
                                     RID_DETECTOR_COUNTER);
            }
        }
    }
}

void pattern_detector_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        pattern_detector_object_t *obj = get_obj(def);
        k_work_cancel_delayable_sync(&obj->measure_accel_dwork, &obj->sync);
        avs_free(obj->instances);
        avs_free(obj);
    }
}
